<pre class="metadata">
Title: Compression Streams
Shortname: compression
Level: none
Status: draft
Group: wicg
ED: https://wicg.github.io/compression-streams/
Editor: Canon Mukai, Google
Editor: Adam Rice, Google
Abstract:
  This document defines a set of JavaScript APIs to compress and decompress a
  stream. The APIs makes it easier to handle streams of Uint8Array for developpers. 
Repository: ricea/compression-streams
Indent: 2
Markup Shorthands: markdown yes
Boilerplate: omit conformance
</pre>
<pre class="link-defaults">
spec:streams; type:interface; text:ReadableStream
spec:html; type:dfn; for:/; text:origin
</pre>
<pre class="anchors">
urlPrefix: http://www.ecma-international.org/ecma-262/6.0/index.html; spec: ECMASCRIPT-6.0
  type: dfn
    text: fulfilled; url: sec-promise-objects
    text: rejected; url: sec-promise-objects
    text: pending; url: sec-promise-objects
    text: resolved; url: sec-promise-objects
    text: settled; url: sec-promise-objects
    
</pre>

# Introduction #    {#introduction}

*This section is non-normative.*

This specificatin is used to compress and decompress streams of data. It supports "deflate" and "gzip" as compression algorithms they are standards among web developpers. If there is a wish to use other algorithm, it is possible to add it to the API. 

# Conformance #  {#conformance}

As well as sections marked as non-normative, all authoring guidelines,
diagrams, examples, and notes in this specification are non-normative.
Everything else in this specification is normative.

The key words *MUST* and *SHOULD* are to be interpreted as described in
[[!RFC2119]].

This specification defines conformance criteria that apply to a single product:
the user agent that implements the interfaces that it contains.

Conformance requirements phrased as algorithms or specific steps may be
implemented in any manner, so long as the end result is equivalent. (In
particular, the algorithms defined in this specification are intended to be
easy to follow, and not intended to be performant.)

Implementations that use ECMAScript to implement the APIs defined in this
specification MUST implement them in a manner consistent with the ECMAScript
Bindings defined in the Web IDL specification [[!WEBIDL-1]], as this
specification uses that specification and terminology.

# Terminology #  {#terminology}

A chunk is a piece of data. In the case of CompressionStream and DecompressionStream, the data is Uint8Array. 

A stream represents an ordered sequence of chunks. The terms {{ReadableStream}} and {{WritableStream}} are defined in
[[!WHATWG-STREAMS]].

Deflate is a format of compression. Gzip is a format of compression, too, and based on deflate algorithm. Both deflate and gzip are defined in zlib.

# Interface Mixin `GenericTransformStream` #  {#generic-transform-stream}

The <dfn interface>GenericTransformStream</dfn> interface mixin represents the comcept of a transform stream in IDL. It is not a TransformStream, though it has the same interface and it delegates to one.

<pre class="idl">
interface mixin GenericTransformStream {
  readonly attribute ReadableStream readable; 
  readonly attribute WritableStream writable;
};
</pre>

An object that includes <dfn interface>GenericTransformStream</dfn> has an associated <dfn>transform</dfn> of type TransformStream.

## Attributes ##  {#outgoing-stream-attributes}

: <dfn attribute for="GenericTransformStream">readable</dfn>
:: The `readable` attribute's getter, when invoked, must return this object's transform {{[[readable]]}}.
: <dfn attribute for="GenericTransformStream">writable</dfn>
:: The `writable` attribute's getter, when invoked, must return this object's transform {{[[writable]]}}.

# Interface `CompressionStream` #  {#compression-stream}

A collection of common attributes and methods of all streams.

<pre class="idl">
[ Exposed=(Window,Worker),
  Constructor(DOMString format),
  ConstructorCallWith=ScriptState,
  RaisesException=Constructor,
  RuntimeException=CompressionStreams ]
interface CompressionStream {
    readonly attribute ReadableStream readable;
    readonly attribute WritableStream writable;
};
</pre>

## Attributes ##  {#compression-stream-attributes}

: <dfn for="CompressionStream" attribute>readable</dfn>
:: The `readable` attribute's getter, when invoked, must return this object's transform {{[[readable]]}}.
: <dfn for="CompressionStream" attribute>writable</dfn>
:: The `writable` attribute's getter, when invoked, must return this object's transform {{[[writable]]}}.

The <dfn interface>CompressionStream(format)</dfn> constructor, when invoked, must run these steps:
    1. Let *format* be the result of the input <dfn>format</dfn>.
    1. If *format* is unsupported in CompressionStream, then throw throw a TypeError.
    1. Let *cs* be a new CompressionStream object.
    1. Let *transformAlgorithm* be an algorithm which takes a *chunk* argument and runs the compress and enqueue a chunk algorithm with *cs* and *chunk*.
    1. If *chunk* is not of supported type, then throw a TypeError.
    1. Let *flushAlgorithm* be an algorithm which takes no argument and runs the flush and enqueue algorithm with *cs*.

The compress and enqueue a chunk algorithm, given a CompressionStream object *cs* and a *chunk*, rus these steps:
    1. Let outBuffer be the result of compressing *chunk*. If this throws an exception, then return a promise rejected with that exception.
    1. Push a copy of outBuffer to *cs*'s stream. If this throws an exception, then return a promise rejected with that exception.
    1. Let *controller* be *cs*'s transform.
    1. Let *output* be a new stream.
    1. While true, run these steps:
       1. Let *token* be the result of reading from *cs*'s stream.
       1. If *token* is end-of-stream, run these steps:
       	  1. Let *outputChunk* be *output*.
	  1. If *outputChunk* is non-empty, call Enqueue.
	  1. Return a new promise resolved with undefined.
       1. Let *result* be the result of processing *token* for *cs*'s comppresser, *cs*'s stream, *output*, and *cs*'s error mode.
       1. If *result* is error, then return a new promise rejected with a TypeError exception.

The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a CompressionStream object *cs*, runs these steps:

    1. Let *output* be a new stream.
    1. Let *result* be the result of processing *token* for *cs*'s decomppresser, *cs*'s stream, *output*, and *cs*'s error mode.
    1. If *result* is finished, run these steps:
       1. Let *outputChunk* be *output*.
       1. Let *controller* be *cs*'s transform.
       1. If *outputChunk* is non-empty, call Enqueue.
       1. Return a new promise resolved with undefined.
    1. Otherwise, return a new promise rejected with a TypeError exception.
    

# Interface `DecompressionStream` #  {#decompression-stream}

A collection of common attributes and methods of all streams.

<pre class="idl">
[ Exposed=(Window,Worker),
  Constructor(DOMString format),
  ConstructorCallWith=ScriptState,
  RaisesException=Constructor,
  RuntimeException=CompressionStreams ]
interface DecompressionStream {
    readonly attribute ReadableStream readable;
    readonly attribute WritableStream writable;
};
</pre>

## Attributes ##  {#decompression-stream-attributes}

: <dfn for="DecompressionStream" attribute>readable</dfn>
:: The `readable` attribute's getter, when invoked, must return this object's transform {{[[readable]]}}.
: <dfn for="DecompressionStream" attribute>writable</dfn>
:: The `writable` attribute's getter, when invoked, must return this object's transform {{[[writable]]}}.

The <dfn interface>DecompressionStream(format)</dfn> constructor, when invoked, must run these steps:
    1. Let *format* be the result of the input <dfn>format</dfn>.
    1. If *format* is unsupported in DecompressionStream, then throw throw a TypeError.
    1. Let *ds* be a new DecompressionStream object.
    1. Let *transformAlgorithm* be an algorithm which takes a *chunk* argument and runs the decompress and enqueue a chunk algorithm with *ds* and *chunk*.
    1. If *chunk* is data which is not compressed by *format* algorithm, then throw a TypeError.
    1. Let *flushAlgorithm* be an algorithm which takes no argument and runs the flush and enqueue algorithm with *ds*.

The decompress and enqueue a chunk algorithm, given a DecompressionStream object *ds* and a *chunk*, rus these steps:
    1. Let outBuffer be the result of decompressing *chunk*. If this throws an exception, then return a promise rejected with that exception.
    1. Push a copy of outBuffer to *ds*'s stream. If this throws an exception, then return a promise rejected with that exception.
    1. Let *controller* be *ds*'s transform.
    1. Let *output* be a new stream.
    1. While true, run these steps:
       1. Let *token* be the result of reading from *ds*'s stream.
       1. If *token* is end-of-stream, run these steps:
       	  1. Let *outputChunk* be *output*.
	  1. If *outputChunk* is non-empty, call Enqueue.
	  1. Return a new promise resolved with undefined.
       1. Let *result* be the result of processing *token* for *ds*'s decomppresser, *ds*'s stream, *output*, and *ds*'s error mode.
       1. If *result* is error, then return a new promise rejected with a TypeError exception.

The flush and enqueue algorithm, which handles the end of data from the input ReadableStream object, given a DecompressionStream object *ds*, runs these steps:

    1. Let *output* be a new stream.
    1. Let *result* be the result of processing *token* for *ds*'s decomppresser, *ds*'s stream, *output*, and *ds*'s error mode.
    1. If *result* is finished, run these steps:
       1. Let *outputChunk* be *output*.
       1. Let *controller* be *ds*'s transform.
       1. If *outputChunk* is non-empty, call Enqueue.
       1. Return a new promise resolved with undefined.
    1. Otherwise, return a new promise rejected with a TypeError exception.


# Privacy and Security Considerations #  {#privacy-security}

The API doesn't add any new privileges to the web platform.

However, web developpers have to pay attention to the situation when attackers get the length of the data. If so, they may be able to guess the contents of the data.

# Examples #  {#examples}

## Gzip-compress a stream ##  {#example-gzip-compress-stream}

<pre class="example" highlight="js">
const compressiedReadableStream
    = inputReadableStream.pipeThrough(new CompressionStream('gzip'));
</pre>

## Deflate-compress an ArrayBuffer to a Uint8Array ##  {#example-deflate-compress}

<pre class="example" highlight="js">
async function compressArrayBuffer(in) {
  const cs = new CompressionStream('deflate');
  const writer = cs.writable.getWriter();
  writer.write(in);
  writer.close();
  const out = [];
  const reader = cs.readable.getReader();
  let totalSize = 0;
  while (true) {
    const { value, done } = await reader.read();
    if (done)
      break;
    out.push(value);
    totalSize += value.byteLength;
  }
  const concatenated = new Uint8Array(totalSize);
  let offset = 0;
  for (const array of out) {
    concatenated.set(array, offset);
    offset += array.byteLength;
  }
  return concatenated;
}
</pre>

## Gzip-decompress a Blob to Blob ##  {#example-gzip-decompress}

<pre class="example" highlight="js">
async function DecompressBlob(blob) {
  const ds = new DecompressionStream('gzip');
  const decompressionStream = blob.stream().pipeThrough(ds);
  return await new Response(decompressedStream).blob();
}
</pre>

# Acknowledgements #  {#acknowledgements}
The editors wish to thank the Working Group chairs and Team Contact, Harald
Alvestrand, Stefan H&aring;kansson, Bernard Aboba and Dominique
Haza&euml;l-Massieux, for their support. Contributions to this specification
were provided by Robin Raymond.

The {{QuicTransport}} and `QuicStream` objects were initially described in the
[W3C ORTC CG](https://www.w3.org/community/ortc/), and have been adapted for
use in this specification.
